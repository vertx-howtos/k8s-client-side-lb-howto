= Client side load balancing on Kubernetes
:page-permalink: /
:page-github: vertx-howtos/k8s-client-side-lb-howto

This document will show you how to perform client side load balancing on Kubernetes with a microservice.

== What you will build

You will build a Vert.x microservice which:

* listens to HTTP requests for the `/` URI
* makes an HTTP request to a back-end service using a load balancer
* sends the back-end service HTTP response content

It consists of a single part (or _microservice_) communicating with another pod deployed in Kubernetes.

== What you need

* A text editor or IDE
* Java 11 higher
* Maven or Gradle
* https://kubernetes.io/docs/tasks/tools/install-minikube/[Minikube] or any Kubernetes cluster
* `kubectl` command-line tool


== Create the project

The code of the _microservice_ project contains Maven and Gradle build files that are functionally equivalent.

=== Dependencies

Both projects depend on:

* https://vertx.io/docs/vertx-core/java[`Vert.x Core`]
* https://vertx.io/docs/5.0.0.CR2/vertx-service-resolver/java/[`Vert.x Service Resolver`]

The Service Resolver library is a plugin that lets Vert.x clients call services using logical service names instead of network addresses. The service resolver is also capable to perform client side load balancing with the usual strategies.

=== Containerization

To create containers we will use https://github.com/GoogleContainerTools/jib[Jib] because:

- it creates images with distinct layers for dependencies, resources and classes, thus saving build time and deployment time
- it supports both Maven and Gradle
- it requires neither Docker nor Podman

=== Using Maven

Here is the content of the `pom.xml` file you should be using for the _frontend_:

ifdef::env-github[]
link:pom.xml[_Microservice_ Maven POM file]
endif::env-github[]
ifndef::env-github[]
[source,xml,role="collapsed"]
._Frontend_ Maven `pom.xml`
----
include::pom.xml[]
----
endif::env-github[]

=== Using Gradle

Assuming you use Gradle with the Kotlin DSL, here is what your `build.gradle.kts` file should look like for the _frontend_:

ifdef::env-github[]
link:build.gradle.kts[_Microservice_ Gradle build file]
endif::env-github[]
ifndef::env-github[]
[source,kotlin,role="collapsed"]
._Microservice_ Gradle `build.gradle.kts`
----
include::build.gradle.kts[]
----
endif::env-github[]

== Implement the service

Let's implement the _microservice_ and then test it on the development machine.

The _frontend_ service is encapsulated in a `MicroServiceVerticle` class.

The service will request another pod of the Kubernetes cluster with a service address.

ifdef::env-github[]
link:src/main/java/io/vertx/howtos/clientsidelb/MicroServiceVerticle.java[MicroServiceVerticle]
endif::env-github[]
ifndef::env-github[]
[source,java,role="collapsed"]
.Java `src/main/java/io/vertx/howtos/clientsidelb/FrontendVerticle.java`
----
include::src/main/java/io/vertx/howtos/clientsidelb/MicroServiceVerticle.java[tag=config]
----
endif::env-github[]


