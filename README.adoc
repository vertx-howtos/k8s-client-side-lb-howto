= Client side load balancing on Kubernetes
:page-permalink: /
:page-github: vertx-howtos/k8s-client-side-lb-howto

ifdef::env-github[]
image:https://github.com/vertx-howtos/k8s-client-side-lb-howto/workflows/Publish%20the%20how-to/badge.svg?branch=master["Build Status", link="https://github.com/vertx-howtos/k8s-client-side-lb-howto/actions?query=workflow%3A%22Publish+the+how-to%22"]
endif::env-github[]

This document will show you how to perform client side load balancing on Kubernetes with a microservice.

== What you will build

You will build a Vert.x microservice which:

* listens to HTTP requests for the `/` URI
* makes an HTTP request to a back-end service using a load balancer
* sends the back-end service HTTP response content

It consists of a single part (or _microservice_) communicating with another pod deployed in Kubernetes.

== What you need

* A text editor or IDE
* Java 11 higher
* Maven or Gradle
* https://kubernetes.io/docs/tasks/tools/install-minikube/[Minikube] or any Kubernetes cluster
* `kubectl` command-line tool


== Create the project

The code of the _microservice_ project contains Maven and Gradle build files that are functionally equivalent.

=== Dependencies

Both projects depend on:

* https://vertx.io/docs/vertx-core/java[`Vert.x Core`]
* https://vertx.io/docs/5.0.0.CR2/vertx-service-resolver/java/[`Vert.x Service Resolver`]

The Service Resolver library is a plugin that lets Vert.x clients call services using logical service names instead of network addresses. The service resolver is also capable to perform client side load balancing with the usual strategies.

=== Containerization

To create containers we will use https://github.com/GoogleContainerTools/jib[Jib] because:

- it creates images with distinct layers for dependencies, resources and classes, thus saving build time and deployment time
- it supports both Maven and Gradle
- it requires neither Docker nor Podman

=== Using Maven

Here is the content of the `pom.xml` file you should be using for the _frontend_:

ifdef::env-github[]
link:pom.xml[_Microservice_ Maven POM file]
endif::env-github[]
ifndef::env-github[]
[source,xml,role="collapsed"]
._Frontend_ Maven `pom.xml`
----
include::pom.xml[]
----
endif::env-github[]

=== Using Gradle

Assuming you use Gradle with the Kotlin DSL, here is what your `build.gradle.kts` file should look like for the _frontend_:

ifdef::env-github[]
link:build.gradle.kts[_Microservice_ Gradle build file]
endif::env-github[]
ifndef::env-github[]
[source,kotlin,role="collapsed"]
._Microservice_ Gradle `build.gradle.kts`
----
include::build.gradle.kts[]
----
endif::env-github[]

== Implement the service

Let's implement the _microservice_ and then test it on the development machine.

The _frontend_ service is encapsulated in a `MicroServiceVerticle` class.

The service will request another pod of the Kubernetes cluster with a service address.

ifdef::env-github[]
link:src/main/java/io/vertx/howtos/clientsidelb/MicroServiceVerticle.java[MicroServiceVerticle]
endif::env-github[]
ifndef::env-github[]
[source,java,role="collapsed"]
.Java `src/main/java/io/vertx/howtos/clientsidelb/FrontendVerticle.java`
----
include::src/main/java/io/vertx/howtos/clientsidelb/MicroServiceVerticle.java[tag=config]
----
endif::env-github[]






TODO TODO TODO
TODO TODO TODO
TODO TODO TODO






When the verticle starts, it sets up a Vert.x Web `Router` and binds an HTTP server:

ifdef::env-github[]
link:frontend/src/main/java/io/vertx/howtos/cluster/FrontendVerticle.java[FrontendVerticle start]
endif::env-github[]
ifndef::env-github[]
[source,java,role="collapsed"]
.Java `frontend/src/main/java/io/vertx/howtos/cluster/FrontendVerticle.java`
----
include::frontend/src/main/java/io/vertx/howtos/cluster/FrontendVerticle.java[tag=start]
----
endif::env-github[]

The `Router` defines a _GET_ handler for the `/hello` URI, besides it exposes health and readiness checks over HTTP:

ifdef::env-github[]
link:frontend/src/main/java/io/vertx/howtos/cluster/FrontendVerticle.java[FrontendVerticle router]
endif::env-github[]
ifndef::env-github[]
[source,java,role="collapsed"]
.Java `frontend/src/main/java/io/vertx/howtos/cluster/FrontendVerticle.java`
----
include::frontend/src/main/java/io/vertx/howtos/cluster/FrontendVerticle.java[tag=router]
----
endif::env-github[]

The HTTP request handler for `/hello` URI extracts the `name` parameter, sends a request over the _event bus_ and forwards the reply to the client:

ifdef::env-github[]
link:frontend/src/main/java/io/vertx/howtos/cluster/FrontendVerticle.java[FrontendVerticle handle-request]
endif::env-github[]
ifndef::env-github[]
[source,java,role="collapsed"]
.Java `frontend/src/main/java/io/vertx/howtos/cluster/FrontendVerticle.java`
----
include::frontend/src/main/java/io/vertx/howtos/cluster/FrontendVerticle.java[tag=handle-request]
----
endif::env-github[]

For local testing, a `main` method is an easy way to start the verticle from the IDE:

ifdef::env-github[]
link:frontend/src/main/java/io/vertx/howtos/cluster/FrontendVerticle.java[FrontendVerticle main]
endif::env-github[]
ifndef::env-github[]
[source,java,role="collapsed"]
.Java `frontend/src/main/java/io/vertx/howtos/cluster/FrontendVerticle.java`
----
include::frontend/src/main/java/io/vertx/howtos/cluster/FrontendVerticle.java[tag=main]
----
endif::env-github[]

=== Test locally

You can start each service:

* straight from your IDE or,
* with Maven: `mvn compile exec:java`, or
* with Gradle: `./gradlew run` (Linux, macOS) or `gradlew run` (Windows).

The _frontend_ service output should print a message similar to the following:

----
2020-07-16 16:29:39,478 [vert.x-eventloop-thread-2] INFO  i.v.howtos.cluster.FrontendVerticle - Server started and listening on port 8080
----

The _backend_:

----
2020-07-16 16:29:40,770 [vert.x-eventloop-thread-2] INFO  i.v.howtos.cluster.BackendVerticle - Server started and listening on port 38621
----

TIP: Take note of the `backend` HTTP server port.
By default it uses a random port to avoid conflict with the `frontend` HTTP server.

NOTE: The following examples use the https://httpie.org/[HTTPie] command line HTTP client.
Please refer to the https://httpie.org/doc#installation[installation] documentation if you don't have it installed on your system yet.

First let's send a request to the _frontend_ for the `/hello` URI with the `name` query param set to `Vert.x Clustering`

----
http :8080/hello name=="Vert.x Clustering"
----

You should see something like:

----
HTTP/1.1 200 OK
content-length: 36

Hello Vert.x Clustering from unknown
----

NOTE: `unknown` is the default pod name used by the _backend_ when the `POD_NAME` environment variable is not defined.

We can also verify the readiness of the _frontend_:

----
http :8080/readiness
HTTP/1.1 200 OK
content-length: 65
content-type: application/json;charset=UTF-8

{
    "checks": [
        {
            "id": "cluster-health",
            "status": "UP"
        }
    ],
    "outcome": "UP"
}
----

And the _backend_:

----
http :38621/readiness
HTTP/1.1 200 OK
content-length: 65
content-type: application/json;charset=UTF-8

{
    "checks": [
        {
            "id": "cluster-health",
            "status": "UP"
        }
    ],
    "outcome": "UP"
----

== Deploy to Kubernetes

First, make sure Minikube has started with `minikube status`.

NOTE: If you don't use Minikube, verify that `kubectl` is connected to your cluster.

=== Push container images

There are https://minikube.sigs.k8s.io/docs/handbook/pushing/[different ways] to push container images to Minikube.

In this document, we will push directly to the in-cluster Docker daemon.
To do so, we must point our shell to Minikube's docker-daemon:

----
eval $(minikube -p minikube docker-env)
----

Then, within the same shell, we can build the images with Jib:

* with Maven: `mvn compile jib:dockerBuild`, or
* with Gradle: `./gradlew jibDockerBuild` (Linux, macOS) or `gradlew jibDockerBuild` (Windows).

NOTE: Jib will not use the Docker daemon to build the image but only to push it.

NOTE: If you don't use Minikube, please refer to the https://github.com/GoogleContainerTools/jib/tree/master/jib-maven-plugin#configuration[Jib Maven] or https://github.com/GoogleContainerTools/jib/tree/master/jib-gradle-plugin#configuration[Jib Gradle] plugin documentation for details about how to configure them when pushing to a registry.

=== Clustered app headless service

On Kubernetes, Infinispan shouldn't use the default networking stack because most often IP multicast is not available.

Instead, we will configure it to use a stack that relies on https://kubernetes.io/docs/concepts/services-networking/service/#headless-services[headless service] lookup for discovery and TCP connections for group messaging.

Let's create a `clustered-app` headless service which selects member pods having the label `cluster:clustered-app`:

ifdef::env-github[]
link:headless-service.yml[Headless Service]
endif::env-github[]
ifndef::env-github[]
[source,java,role="collapsed"]
.YML `headless-service.yml`
----
include::headless-service.yml[]
----
endif::env-github[]

IMPORTANT: The headless service must account for pods even when not ready (`publishNotReadyAddresses` set to `true`).

Apply this configuration:

----
kubectl apply -f headless-service.yml
----

Then verify it was succesful:

----
kubectl get services clustered-app
----

You should see something like:

----
NAME            TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)    AGE
clustered-app   ClusterIP   None         <none>        7800/TCP   63m
----

=== _Frontend_ deployment and service

Let's deploy the _frontend_ service now.

We want at least two replicas for high availability.

To configure Vert.x Infinispan, we need to start the JVM with a few system properties:

* `java.net.preferIPv4Stack`
* `vertx.jgroups.config`: networking stack configuration file, set to `default-configs/default-jgroups-kubernetes.xml`
* `jgroups.dns.query`: the DNS name of the headless service we just created

And then Kubernetes needs to know the URI for liveness, readiness and startup probes.

TIP: The startup probe can point to the readiness URI with different timeout settings.

ifdef::env-github[]
link:frontend/deployment.yml[Frontend Deployment]
endif::env-github[]
ifndef::env-github[]
[source,java,role="collapsed"]
.YML `frontend/deployment.yml`
----
include::frontend/deployment.yml[]
----
endif::env-github[]

Apply this configuration:

----
kubectl apply -f frontend/deployment.yml
----

Verify the pods have started successfully:

----
kubectl get pods
----

You should see something like:

----
NAME                                  READY   STATUS    RESTARTS   AGE
frontend-deployment-8cfd4d966-lpvsb   1/1     Running   0          4m58s
frontend-deployment-8cfd4d966-tctgv   1/1     Running   0          4m58s
----

We also need a service to load-balance the HTTP traffic.
Pods will be selected by the label `app:frontend` that was defined in the deployment:

ifdef::env-github[]
link:frontend/service.yml[Frontend Service]
endif::env-github[]
ifndef::env-github[]
[source,java,role="collapsed"]
.YML `frontend/service.yml`
----
include::frontend/service.yml[]
----
endif::env-github[]

Apply this configuration:

----
kubectl apply -f frontend/service.yml
----

Verify the service has been created successfully:

----
kubectl get services frontend
----

You should see something like:

----
NAME       TYPE           CLUSTER-IP     EXTERNAL-IP   PORT(S)        AGE
frontend   LoadBalancer   10.106.16.88   <pending>     80:30729/TCP   62s
----

If you use Minikube, open another terminal window and run:

----
minikube tunnel
----

https://minikube.sigs.k8s.io/docs/handbook/accessing/#using-minikube-tunnel[Minikube tunnel] runs as a separate process and exposes the service to the host operating system.

If you run `kubectl get services frontend` again, then the external IP should be set:

----
NAME       TYPE           CLUSTER-IP      EXTERNAL-IP     PORT(S)        AGE
frontend   LoadBalancer   10.100.254.64   10.100.254.64   80:30660/TCP   30m
----

TIP: Take note of the external IP.

[IMPORTANT]
====
Minikube tunnel requires privilege escalation.
If you are not granted to do this, you can still access the service via the _NodePort_ with `minikube service --url frontend`.
====

NOTE: If you don't use Minikube and no external IP has been assigned to your service, please refer to your cluster documentation.

=== _Backend_ deployment

The _backend_ service deployment is similar to the _frontend_ one.

Notice that in this case:

* 3 replicas should be created
* the `POD_NAME` environment variable will be set in the container

ifdef::env-github[]
link:backend/deployment.yml[Backend Deployment]
endif::env-github[]
ifndef::env-github[]
[source,java,role="collapsed"]
.YML `backend/deployment.yml`
----
include::backend/deployment.yml[]
----
endif::env-github[]


Apply this configuration:

----
kubectl apply -f backend/deployment.yml
----

Verify the pods have started successfully:

----
kubectl get pods
----

You should see something like:

----
NAME                                  READY   STATUS    RESTARTS   AGE
backend-deployment-74d7f45c67-h7h9c   1/1     Running   0          63s
backend-deployment-74d7f45c67-r45bc   1/1     Running   0          63s
backend-deployment-74d7f45c67-r75ht   1/1     Running   0          63s
frontend-deployment-8cfd4d966-lpvsb   1/1     Running   0          15m
frontend-deployment-8cfd4d966-tctgv   1/1     Running   0          15m
----

=== Testing remotely

We can now send a request to the _frontend_ for the `/hello` URI with the `name` query param set to `Vert.x Clustering`

----
http 10.100.254.64/hello name=="Vert.x Clustering"
----

You should see something like:

----
HTTP/1.1 200 OK
content-length: 64

Hello Vert.x Clustering from backend-deployment-74d7f45c67-6r2g2
----

Notice that we can see now the name of the pod instead of the default value (`unknown`).

Also, if you send requests repeatedly, you will see that the `backend` services receive `event bus` requests in a round-robin fashion.

== Summary

This document covered:

* dependencies required to deploy clustered Vert.x apps on Kubernetes with Infinispan
* containerization of Vert.x services with Jib
* configuration of the Vert.x Infinispan cluster manager for local testing and deployment on Kubernetes

== See also

* https://github.com/GoogleContainerTools/jib/[`Containerization with Jib`]
* https://vertx.io/docs/vertx-infinispan/java/#_configuring_for_kubernetes[Configuring Vert.x Infinispan for Kubernetes]
* https://kubernetes.io/docs/concepts/services-networking/service/#headless-services[Creating Kubernetes headless services]
* https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/[Configure Liveness, Readiness and Startup Probes]
* https://vertx.io/docs/vertx-health-check/java[`Vert.x Health Check`]
